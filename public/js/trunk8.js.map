{"version":3,"sources":["trunk8.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"trunk8.js","sourcesContent":["/**!\n * trunk8 v1.3.3\n * https://github.com/rviscomi/trunk8\n * \n * Copyright 2012 Rick Viscomi\n * Released under the MIT License.\n * \n * Date: September 26, 2012\n */\n\n(function ($) {\n\tvar methods,\n\t\tutils,\n\t\tSIDES = {\n\t\t\t/* cen...ter */\n\t\t\tcenter: 'center',\n\t\t\t/* ...left */\n\t\t\tleft: 'left',\n\t\t\t/* right... */\n\t\t\tright: 'right'\n\t\t},\n\t\tWIDTH = {\n\t\t\tauto: 'auto'\n\t\t};\n\t\n\tfunction trunk8(element) {\n\t\tthis.$element = $(element);\n\t\tthis.original_text = this.$element.html().trim();\n\t\tthis.settings = $.extend({}, $.fn.trunk8.defaults);\n\t}\n\t\n\ttrunk8.prototype.updateSettings = function (options) {\n\t\tthis.settings = $.extend(this.settings, options);\n\t};\n\n\tfunction stripHTML(html) {\n\t\tvar tmp = document.createElement(\"DIV\");\n\t\ttmp.innerHTML = html;\n\t\t\n\t\tif (typeof tmp.textContent != 'undefined') {\n\t\t\treturn tmp.textContent;\n\t\t}\n\n\t\treturn tmp.innerText\n\t}\n\n\tfunction getHtmlArr(str) {\n\t\t/* Builds an array of strings and designated */\n\t\t/* HTML tags around them. */\n\t\tif (stripHTML(str) === str) {\n\t\t\treturn str.split(/\\s/g);\n\t\t}\n\t\tvar allResults = [],\n\t\t\treg = /<([a-z]+)([^<]*)(?:>(.*?(?!<\\1>)*)<\\/\\1>|\\s+\\/>)(['.?!,]*)|((?:[^<>\\s])+['.?!,]*\\w?|<br\\s?\\/?>)/ig,\n\t\t\toutArr = reg.exec(str),\n\t\t\tlastI,\n\t\t\tind;\n\t\twhile (outArr && lastI !== reg.lastIndex) {\n\t\t\tlastI = reg.lastIndex;\n\t\t\tif (outArr[5]) {\n\t\t\t\tallResults.push(outArr[5]);\n\t\t\t} else if (outArr[1]) {\n\t\t\t\tallResults.push({\n\t\t\t\t\ttag: outArr[1],\n\t\t\t\t\tattribs: outArr[2],\n\t\t\t\t\tcontent: outArr[3],\n\t\t\t\t\tafter: outArr[4]\n\t\t\t\t});\n\t\t\t}\n\t\t\toutArr = reg.exec(str);\n\t\t}\n\t\tfor (ind = 0; ind < allResults.length; ind++) {\n\t\t\tif (typeof allResults[ind] !== 'string' &&\n\t\t\t\t\tallResults[ind].content) {\n\t\t\t\tallResults[ind].content = getHtmlArr(allResults[ind].content);\n\t\t\t}\n\t\t}\n\t\treturn allResults;\n\t}\n\n\tfunction rebuildHtmlFromBite(bite, htmlObject, fill) {\n\t\t// Take the processed bite after binary-search\n\t\t// truncated and re-build the original HTML\n\t\t// tags around the processed string.\n\t\tbite = bite.replace(fill, '');\n\n\t\tvar biteHelper = function(contentArr, tagInfo) {\n\t\t\t\tvar retStr = '',\n\t\t\t\t\tcontent,\n\t\t\t\t\tbiteContent,\n\t\t\t\t\tbiteLength,\n\t\t\t\t\tnextWord,\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < contentArr.length; i++) {\n\t\t\t\t\tcontent = contentArr[i];\n\t\t\t\t\tbiteLength = $.trim(bite).split(' ').length;\n\t\t\t\t\tif ($.trim(bite).length) {\n\t\t\t\t\t\tif (typeof content === 'string') {\n\t\t\t\t\t\t\tif (!/<br\\s*\\/?>/.test(content)) {\n\t\t\t\t\t\t\t\tif (biteLength === 1 && $.trim(bite).length <= content.length) {\n\t\t\t\t\t\t\t\t\tcontent = bite;\n\t\t\t\t\t\t\t\t\t// We want the fill to go inside of the last HTML\n\t\t\t\t\t\t\t\t\t// element if the element is a container.\n\t\t\t\t\t\t\t\t\tif (tagInfo === 'p' || tagInfo === 'div') {\n\t\t\t\t\t\t\t\t\t\tcontent += fill;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbite = '';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbite = bite.replace(content, '');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tretStr += $.trim(content) + ((i === contentArr.length-1 || biteLength <= 1) ? '' : ' ');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbiteContent = biteHelper(content.content, content.tag);\n\t\t\t\t\t\t\tif (content.after) bite = bite.replace(content.after, '');\n\t\t\t\t\t\t\tif (biteContent) {\n\t\t\t\t\t\t\t\tif (!content.after) content.after = ' ';\n\t\t\t\t\t\t\t\tretStr += '<'+content.tag+content.attribs+'>'+biteContent+'</'+content.tag+'>' + content.after;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn retStr;\n\t\t\t},\n\t\t\thtmlResults = biteHelper(htmlObject);\n\n\t\t// Add fill if doesn't exist. This will place it outside the HTML elements.\n\t\tif (htmlResults.slice(htmlResults.length - fill.length) === fill) {\n\t\t\thtmlResults += fill;\n\t\t}\n\n\t\treturn htmlResults;\n\t}\n\n\tfunction truncate() {\n\t\tvar data = this.data('trunk8'),\n\t\t\tsettings = data.settings,\n\t\t\twidth = settings.width,\n\t\t\tside = settings.side,\n\t\t\tfill = settings.fill,\n\t\t\tparseHTML = settings.parseHTML,\n\t\t\tline_height = utils.getLineHeight(this) * settings.lines,\n\t\t\tstr = data.original_text,\n\t\t\tlength = str.length,\n\t\t\tmax_bite = '',\n\t\t\tlower, upper,\n\t\t\tbite_size,\n\t\t\tbite,\n\t\t\ttext,\n\t\t\thtmlObject;\n\t\t\n\t\t/* Reset the field to the original string. */\n\t\tthis.html(str);\n\t\ttext = this.text();\n\n\t\t/* If string has HTML and parse HTML is set, build */\n\t\t/* the data struct to house the tags */\n\t\tif (parseHTML && stripHTML(str) !== str) {\n\t\t\thtmlObject = getHtmlArr(str);\n\t\t\tstr = stripHTML(str);\n\t\t\tlength = str.length;\n\t\t}\n\n\t\tif (width === WIDTH.auto) {\n\t\t\t/* Assuming there is no \"overflow: hidden\". */\n\t\t\tif (this.height() <= line_height) {\n\t\t\t\t/* Text is already at the optimal trunkage. */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Binary search technique for finding the optimal trunkage. */\n\t\t\t/* Find the maximum bite without overflowing. */\n\t\t\tlower = 0;\n\t\t\tupper = length - 1;\n\n\t\t\twhile (lower <= upper) {\n\t\t\t\tbite_size = lower + ((upper - lower) >> 1);\n\t\t\t\t\n\t\t\t\tbite = utils.eatStr(str, side, length - bite_size, fill);\n\n\t\t\t\tif (parseHTML && htmlObject) {\n\t\t\t\t\tbite = rebuildHtmlFromBite(bite, htmlObject, fill);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.html(bite);\n\n\t\t\t\t/* Check for overflow. */\n\t\t\t\tif (this.height() > line_height) {\n\t\t\t\t\tupper = bite_size - 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlower = bite_size + 1;\n\n\t\t\t\t\t/* Save the bigger bite. */\n\t\t\t\t\tmax_bite = (max_bite.length > bite.length) ? max_bite : bite;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Reset the content to eliminate possible existing scroll bars. */\n\t\t\tthis.html('');\n\t\t\t\n\t\t\t/* Display the biggest bite. */\n\t\t\tthis.html(max_bite);\n\t\t\t\n\t\t\tif (settings.tooltip) {\n\t\t\t\tthis.attr('title', text);\n\t\t\t}\n\t\t}\n\t\telse if (!isNaN(width)) {\n\t\t\tbite_size = length - width;\n\n\t\t\tbite = utils.eatStr(str, side, bite_size, fill);\n\n\t\t\tthis.html(bite);\n\t\t\t\n\t\t\tif (settings.tooltip) {\n\t\t\t\tthis.attr('title', str);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$.error('Invalid width \"' + width + '\".');\n\t\t\treturn;\n\t\t}\n\t\tsettings.onTruncate();\n\t}\n\n\tmethods = {\n\t\tinit: function (options) {\n\t\t\treturn this.each(function () {\n\t\t\t\tvar $this = $(this),\n\t\t\t\t\tdata = $this.data('trunk8');\n\t\t\t\t\n\t\t\t\tif (!data) {\n\t\t\t\t\t$this.data('trunk8', (data = new trunk8(this)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdata.updateSettings(options);\n\t\t\t\t\n\t\t\t\ttruncate.call($this);\n\t\t\t});\n\t\t},\n\n\t\t/** Updates the text value of the elements while maintaining truncation. */\n\t\tupdate: function (new_string) {\n\t\t\treturn this.each(function () {\n\t\t\t\tvar $this = $(this);\n\t\t\t\t\n\t\t\t\t/* Update text. */\n\t\t\t\tif (new_string) {\n\t\t\t\t\t$this.data('trunk8').original_text = new_string;\n\t\t\t\t}\n\n\t\t\t\t/* Truncate accordingly. */\n\t\t\t\ttruncate.call($this);\n\t\t\t});\n\t\t},\n\t\t\n\t\trevert: function () {\n\t\t\treturn this.each(function () {\n\t\t\t\t/* Get original text. */\n\t\t\t\tvar text = $(this).data('trunk8').original_text;\n\t\t\t\t\n\t\t\t\t/* Revert element to original text. */\n\t\t\t\t$(this).html(text);\n\t\t\t});\n\t\t},\n\n\t\t/** Returns this instance's settings object. NOT CHAINABLE. */\n\t\tgetSettings: function () {\n\t\t\treturn $(this.get(0)).data('trunk8').settings;\n\t\t}\n\t};\n\n\tutils = {\n\t\t/** Replaces [bite_size] [side]-most chars in [str] with [fill]. */\n\t\teatStr: function (str, side, bite_size, fill) {\n\t\t\tvar length = str.length,\n\t\t\t\tkey = utils.eatStr.generateKey.apply(null, arguments),\n\t\t\t\thalf_length,\n\t\t\t\thalf_bite_size;\n\n\t\t\t/* If the result is already in the cache, return it. */\n\t\t\tif (utils.eatStr.cache[key]) {\n\t\t\t\treturn utils.eatStr.cache[key];\n\t\t\t}\n\t\t\t\n\t\t\t/* Common error handling. */\n\t\t\tif ((typeof str !== 'string') || (length === 0)) {\n\t\t\t\t$.error('Invalid source string \"' + str + '\".');\n\t\t\t}\n\t\t\tif ((bite_size < 0) || (bite_size > length)) {\n\t\t\t\t$.error('Invalid bite size \"' + bite_size + '\".');\n\t\t\t}\n\t\t\telse if (bite_size === 0) {\n\t\t\t\t/* No bite should show no truncation. */\n\t\t\t\treturn str;\n\t\t\t}\n\t\t\tif (typeof (fill + '') !== 'string') {\n\t\t\t\t$.error('Fill unable to be converted to a string.');\n\t\t\t}\n\n\t\t\t/* Compute the result, store it in the cache, and return it. */\n\t\t\tswitch (side) {\n\t\t\t\tcase SIDES.right:\n\t\t\t\t\t/* str... */\n\t\t\t\t\treturn utils.eatStr.cache[key] =\n\t\t\t\t\t\t\t$.trim(str.substr(0, length - bite_size)) + fill;\n\t\t\t\t\t\n\t\t\t\tcase SIDES.left:\n\t\t\t\t\t/* ...str */\n\t\t\t\t\treturn utils.eatStr.cache[key] =\n\t\t\t\t\t\t\tfill + $.trim(str.substr(bite_size));\n\t\t\t\t\t\n\t\t\t\tcase SIDES.center:\n\t\t\t\t\t/* Bit-shift to the right by one === Math.floor(x / 2) */\n\t\t\t\t\thalf_length = length >> 1; // halve the length\n\t\t\t\t\thalf_bite_size = bite_size >> 1; // halve the bite_size\n\n\t\t\t\t\t/* st...r */\n\t\t\t\t\treturn utils.eatStr.cache[key] =\n\t\t\t\t\t\t\t$.trim(utils.eatStr(str.substr(0, length - half_length), SIDES.right, bite_size - half_bite_size, '')) +\n\t\t\t\t\t\t\tfill +\n\t\t\t\t\t\t\t$.trim(utils.eatStr(str.substr(length - half_length), SIDES.left, half_bite_size, ''));\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\t$.error('Invalid side \"' + side + '\".');\n\t\t\t}\n\t\t},\n\t\t\n\t\tgetLineHeight: function (elem) {\n\t\t\t\tvar floats = $(elem).css('float');\n\t\t\t\tif (floats !== 'none') {\n\t\t\t\t\t$(elem).css('float', 'none');\n\t\t\t\t}\n\t\t\t\tvar pos = $(elem).css('position');\n\t\t\t\tif (pos === 'absolute') {\n\t\t\t\t\t$(elem).css('position', 'static');\n\t\t\t\t}\n\t\n\t\t\t\tvar html = $(elem).html(),\n\t\t\t\twrapper_id = 'line-height-test',\n\t\t\t\tline_height;\n\t\n\t\t\t\t/* Set the content to a small single character and wrap. */\n\t\t\t\t$(elem).html('i').wrap('<div id=\"' + wrapper_id + '\" />');\n\t\n\t\t\t\t/* Calculate the line height by measuring the wrapper.*/\n\t\t\t\tline_height = $('#' + wrapper_id).innerHeight();\n\t\n\t\t\t\t/* Remove the wrapper and reset the content. */\n\t\t\t\t$(elem).html(html).css({ 'float': floats, 'position': pos }).unwrap();\n\t\n\t\t\t\treturn line_height;\n\t\t\t}\n\t};\n\n\tutils.eatStr.cache = {};\n\tutils.eatStr.generateKey = function () {\n\t\treturn Array.prototype.join.call(arguments, '');\n\t};\n\t\n\t$.fn.trunk8 = function (method) {\n\t\tif (methods[method]) {\n\t\t\treturn methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n\t\t}\n\t\telse if (typeof method === 'object' || !method) {\n\t\t\treturn methods.init.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\t$.error('Method ' + method + ' does not exist on jQuery.trunk8');\n\t\t}\n\t};\n\t\n\t/* Default trunk8 settings. */\n\t$.fn.trunk8.defaults = {\n\t\tfill: '&hellip;',\n\t\tlines: 1,\n\t\tside: SIDES.right,\n\t\ttooltip: true,\n\t\twidth: WIDTH.auto,\n\t\tparseHTML: false,\n\t\tonTruncate: function () {}\n\t};\n})(jQuery);\n"],"sourceRoot":"/source/"}